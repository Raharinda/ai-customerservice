/**
 * Gemini API Integration
 * Handle communication with Google Gemini AI
 */

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_MODEL = 'gemini-2.5-flash'; // ‚úÖ Using Gemini 2.5 Flash (as requested)

if (!GEMINI_API_KEY) {
  console.warn('‚ö†Ô∏è GEMINI_API_KEY not found in environment variables');
}

/**
 * Call Gemini API with prompt
 * @param {string} prompt - The prompt to send to Gemini
 * @param {number} retries - Number of retries on failure
 * @returns {Promise<string>} - Raw text response from Gemini
 */
export async function callGemini(prompt, retries = 2) {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY is not configured');
  }

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

  console.log(`üîÆ Calling Gemini API... (retries left: ${retries})`);
  console.log(`üìù Model: ${GEMINI_MODEL}`);
  console.log(`üì§ Prompt length: ${prompt.length} characters`);

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: prompt
              }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 2048, // ‚úÖ Increased to prevent truncated responses
        },
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('‚ùå Gemini API error:', {
        status: response.status,
        statusText: response.statusText,
        error: errorData,
      });
      
      // ‚úÖ Retry on server errors (5xx)
      if (response.status >= 500 && retries > 0) {
        console.log(`üîÑ Retrying due to server error... (${retries} retries left)`);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s before retry
        return callGemini(prompt, retries - 1);
      }
      
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    // Extract text from Gemini response
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!generatedText) {
      console.error('‚ùå No text in Gemini response:', JSON.stringify(data, null, 2));
      
      // ‚úÖ Retry if no text generated
      if (retries > 0) {
        console.log(`üîÑ Retrying due to empty response... (${retries} retries left)`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        return callGemini(prompt, retries - 1);
      }
      
      throw new Error('No text generated by Gemini');
    }

    console.log(`‚úÖ Gemini API response received`);
    console.log(`üì• Response length: ${generatedText.length} characters`);

    return generatedText;

  } catch (error) {
    console.error('‚ùå Error calling Gemini API:', error.message);
    
    // ‚úÖ Retry on network errors
    if (retries > 0 && (error.message.includes('fetch') || error.message.includes('network'))) {
      console.log(`üîÑ Retrying due to network error... (${retries} retries left)`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      return callGemini(prompt, retries - 1);
    }
    
    throw error;
  }
}

/**
 * Analyze customer support ticket with Gemini
 * @param {Object} ticketData - Ticket data to analyze
 * @param {string} prompt - Generated prompt
 * @returns {Promise<Object>} - Parsed AI analysis result
 */
export async function analyzeTicketWithGemini(ticketData, prompt) {
  console.log(`ü§ñ Starting Gemini analysis for ticket...`);
  
  try {
    // Call Gemini API
    const geminiResponse = await callGemini(prompt);
    
    console.log(`‚úÖ Gemini analysis complete`);
    
    return geminiResponse;

  } catch (error) {
    console.error('‚ùå Gemini analysis failed:', error.message);
    throw error;
  }
}
